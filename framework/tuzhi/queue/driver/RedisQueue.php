<?php
/**
 * Created by PhpStorm.
 * User: 吾色禅师<wuse@chanshi.me>
 * Date: 2016/12/13
 * Time: 17:42
 */


namespace tuzhi\queue\driver;

use tuzhi\contracts\queue\IQueue;
use tuzhi\nosql\redis\Connection;
use tuzhi\nosql\redis\Database;
use tuzhi\queue\job\RedisJob;
use tuzhi\queue\Payload;
use tuzhi\queue\Queue;

/**
 * Class RedisQuery
 * @package tuzhi\queue\driver
 */
class RedisQueue extends Queue implements IQueue
{
    /**
     * @var string
     */
    public $driver = 'redis';

    /**
     * @var string
     */
    public $prefix = 'queue-';

    /**
     * @var
     */
    public $server;

    /**
     * @var array
     */
    protected $queue = [];

    /**
     * @var array
     */
    protected $redisKeys = [];

    /**
     * @var Database
     */
    private $redis;

    /**
     *
     */
    public function init()
    {
        parent::init(); // TODO: Change the autogenerated stub
        $this->redisKeys =
            [
                'ready' => $this->prefix.$this->getName(),
                'delayed' => $this->prefix.$this->getName().'-delayed',
                'reserved'=> $this->prefix.$this->getName().'-reserved'
            ];
        $this->redis = \Tuzhi::make(
            [
                'class'=>Connection::className(),
                'redis'=>$this->server
            ]
        );
        $this->redis = $this->redis->getDb();

    }

    /**
     * @param $job
     * @return mixed
     */
    public function push($job)
    {
        $Payload = $this->createPayload($job);
        return $this->pushRaw($Payload);
    }

    /**
     * @param $Payload
     * @return mixed
     */
    public function pushRaw($Payload)
    {
        $this->getReady()->lPush( $Payload );
        return $this->getMetaId($Payload);
    }

    /**
     * @param $job
     * @param $delay
     * @return mixed
     */
    public function later($job, $delay)
    {
        $payload = $this->createPayload($job);
        return $this->laterRaw($payload,$delay);
    }

    /**
     * @param $Payload
     * @param $delay
     * @return mixed
     */
    public function laterRaw( $Payload ,$delay)
    {
        $this->getDelayed()->add( $this->getTime() + $delay,$Payload);
        return $this->getMetaId($Payload);
    }

    /**
     * @return mixed
     */
    public function pop()
    {

        $this->migrateAll();

        $payload = $this->getReady()->rPop();
       // $payload = $this->setMeta($payload,'runAt',$this->getTime());
        $this->getReserved()->add($this->getTime(),$payload);


        return new RedisJob(
            [
                'raw'   =>$payload,
                'queue' =>$this
            ]);
    }

    /**
     * @return mixed
     */
    public function migrateAll()
    {
        $this->migrateDelayed();
        $this->migrateRelease();
    }

    /**
     * @return mixed
     */
    public function migrateDelayed()
    {
//        return $this->redis->transaction($this->redisKeys['delayed'],function( $db ){
            $time = $this->getTime();
            $jobs = $this->getDelayed()->rangeByScore(0,$time);

            //print_r($jobs);exit;
            if( is_array($jobs) && count($jobs) > 0 ){
                $this->getDelayed()->removeByScore(0,$time);
                //PUSH
                $this->getReady()->lPush($jobs);
            }
            return true;
//        });
    }

    /**
     * @param $payload
     */
    public function releaseToReady( $payload )
    {
        $this->pushRaw($payload);
        $this->deleteReserved($payload);
    }

    /**
     * @return mixed
     */
    public function migrateRelease()
    {
        return $this->redis->transaction($this->redisKeys['reserved'],function ( $db ){

            $time = $this->getTime();
            $jobs = $this->getReserved()->rangeByScore(0,$time);

            if( is_array($jobs) && count($jobs) > 0 ){
                $this->getReady()->lPush($jobs);
                $this->getReserved()->removeByScore(0,$time);
            }
            return true;
        });
    }

    /**
     * @param $payload
     * @param $delay
     */
    public function releaseToDelayed($payload ,$delay)
    {
        $this->laterRaw($payload,$delay);
        $this->deleteReserved($payload);
    }

    /**
     * @param $payload
     * @return mixed
     */
    public function deleteReserved( $payload )
    {
        return $this->getReserved()->remove( $payload );
    }

    /**
     * @return mixed
     */
    protected function getReady()
    {

        $key  = $this->redisKeys['ready'];
        return ! isset( $this->queue['ready'] )
            ? ($this->queue['ready'] = $this->redis[$key]->List() )
            : $this->queue['ready'];
    }

    /**
     * @return mixed
     */
    protected function getDelayed()
    {
        $key  = $this->redisKeys['delayed'];
        return ! isset( $this->queue['delayed'] )
            ? ($this->queue['delayed'] = $this->redis[$key]->ZSet() )
            : $this->queue['delayed'];
    }

    /**
     * @return mixed
     */
    protected function getReserved()
    {
        $key  = $this->redisKeys['reserved'];
        return ! isset( $this->queue['reserved'] )
            ? ($this->queue['reserved'] = $this->redis[$key]->ZSet() )
            : $this->queue['reserved'];
    }

    /**
     * @return array
     */
    public function getCount()
    {
        return
            [
                'readyLength' => $this->getReady()->length(),
                'reservedLength' => $this->getReserved()->card(),
                'delayedLength'=> $this->getDelayed()->card()
            ];
    }
    public function clearReady()
    {
        $this->getReady()->splice(0,3);
    }

}